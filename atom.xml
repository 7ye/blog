<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>sevennight</title>
  
  <subtitle>技术笔记</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://sevennight.cc/"/>
  <updated>2019-01-01T04:09:41.346Z</updated>
  <id>http://sevennight.cc/</id>
  
  <author>
    <name>sevennight</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hexo简洁主题推荐分享</title>
    <link href="http://sevennight.cc/2016/10/25/hexo_theme_maupassant_share.html"/>
    <id>http://sevennight.cc/2016/10/25/hexo_theme_maupassant_share.html</id>
    <published>2016-10-25T01:30:01.000Z</published>
    <updated>2019-01-01T04:09:41.346Z</updated>
    
    <content type="html"><![CDATA[<p>Maupassant是Cho为typecho平台设计的一套响应式模板，其简洁的风格让很多人喜爱，在没有被扩展其他功能的情况下整个模板本身小巧到只有几十KB，因此访问速度也可观</p><p><img src="/image/hexo_theme_maupassant_share2.png" alt="Hexo Maupassant博客主题"><br><a id="more"></a></p><p>之前一直用的是php博客系统，但奈何我发现近些时间不是很喜欢折腾博客了，只想有事写两篇，没事放着生蛋，就想着换到github上来在保留绝对控制权的情况下让github托管着，在jekyll和hexo比较中看到了hexo主题中被人移植到hexo的Maupassant模板，感觉很适合我，于是借鉴cho大神最新版的Maupassant主题，结合其他博主（例：<a href="https://www.haomwei.com/technology/maupassant-hexo.html" target="_blank" rel="noopener">屠城博客</a>）的一些扩展上进行了移植与修改</p><p>由于自己特爱简洁，所以移植了最基本的功能，加入了少量的博客可能用得着的其他小扩展，有用得着的朋友可以进入github下载  </p><p><a href="https://github.com/7ye/maupassant-hexo" target="_blank" rel="noopener">https://github.com/7ye/maupassant-hexo</a></p><h2 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">fancybox:</span> <span class="literal">true</span> <span class="comment">## 是否启用Fancybox图片灯箱效果 true/false.</span></span><br><span class="line"><span class="attr">disqus:</span>  <span class="comment">## disqus用户名，为空则不使用</span></span><br><span class="line"><span class="attr">google_search:</span> <span class="literal">true</span> <span class="comment">## 使用google搜索引擎, true/false.</span></span><br><span class="line"><span class="attr">baidu_search:</span> <span class="comment">## 使用百度搜索引擎, true/false.</span></span><br><span class="line"><span class="attr">google_analytics:</span> <span class="comment">## Google统计ID</span></span><br><span class="line"><span class="attr">baidu_analytics:</span> <span class="comment">## 百度统计ID</span></span><br><span class="line"><span class="attr">show_category_count:</span> <span class="literal">true</span> <span class="comment">## 如果你想显示侧边栏分类下的文章数量，请设置值为true</span></span><br><span class="line"><span class="attr">busuanzi:</span> <span class="literal">true</span> <span class="comment">## 使用不蒜子统计文章访问量 true/false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 头部菜单</span></span><br><span class="line"><span class="attr">menu:</span> </span><br><span class="line"><span class="attr">  - page:</span> <span class="string">home</span></span><br><span class="line"><span class="attr">    directory:</span> <span class="string">.</span></span><br><span class="line"><span class="attr">  - page:</span> <span class="string">archive</span></span><br><span class="line"><span class="attr">    directory:</span> <span class="string">archives/</span></span><br><span class="line"><span class="attr">  - page:</span> <span class="string">about</span></span><br><span class="line"><span class="attr">    directory:</span> <span class="string">about/</span></span><br><span class="line"><span class="attr">  - page:</span> <span class="string">rss</span></span><br><span class="line"><span class="attr">    directory:</span> <span class="string">atom.xml</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 侧边栏小工具设置: search, category, tag, recent_posts, links</span></span><br><span class="line"><span class="attr">widgets:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">search</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">category</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">tag</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">recent_posts</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">links</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 侧边栏链接</span></span><br><span class="line"><span class="attr">links:</span> </span><br><span class="line"><span class="attr">  - title:</span> <span class="string">标题</span></span><br><span class="line"><span class="attr">    url:</span> <span class="attr">http://www.example.com</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 静态文件目录</span></span><br><span class="line"><span class="attr">js:</span> <span class="string">js</span></span><br><span class="line"><span class="attr">css:</span> <span class="string">css</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 主题版本</span></span><br><span class="line"><span class="attr">version:</span> <span class="number">0.0</span><span class="number">.1</span></span><br></pre></td></tr></table></figure><ul><li>fancybox：是否启用<a href="http://fancyapps.com/fancybox/" target="_blank" rel="noopener">Fancybox</a>图片灯箱效果</li><li>disqus：<a href="https://disqus.com/" target="_blank" rel="noopener">Disqus评论</a> shortname</li><li>google_search：默认使用Google搜索引擎</li><li>baidu_search：若想使用百度搜索，将其设定为<code>true</code></li><li>google_analytics：<a href="https://www.google.com/analytics/" target="_blank" rel="noopener">Google Analytics</a> 跟踪ID</li><li>baidu_analytics：<a href="http://tongji.baidu.com/" target="_blank" rel="noopener">百度统计</a> 跟踪ID</li><li>show_category_count：是否显示侧边栏分类数目</li><li>busuanzi：是否使用<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener">不蒜子</a>页面访问计数</li><li>menu：自定义页面及菜单，依照已有格式填写。填写后请在<code>source</code>目录下建立相应名称的文件夹</li><li>widgets：选择和排列希望使用的侧边栏小工具</li><li>links： 友情链接，请依照格式填写。</li><li>静态文件目录：静态文件存储路径，方便设置CDN缓存</li><li>version：主题版本，便于静态文件更新后刷新CDN缓存</li></ul><h2 id="主题特性"><a href="#主题特性" class="headerlink" title="主题特性"></a>主题特性</h2><h3 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h3><p>首页默认显示文章摘要而非全文，可以在文章的<code>front-matter</code>中填写一项<code>description:</code>来设置你想显示的摘要，或者直接在文章内容中插入<code>&lt;!--more--&gt;</code>以隐藏后面的内容。<br>若两者都未设置，则自动截取文章第一段作为摘要。</p><h3 id="description描述"><a href="#description描述" class="headerlink" title="description描述"></a>description描述</h3><p>对于首页的<code>description</code>，可在Hexo下的配置文件<code>_config.yml</code>下配置<code>description</code>参数，对于文章，可在<code>front-matter</code>中填写一项<code>description:</code>来手动写描述，如果文章没有任何配置，则自动截取文章前150个字符为当前文章的<code>description</code>（不包括html标签）</p><h3 id="添加页面"><a href="#添加页面" class="headerlink" title="添加页面"></a>添加页面</h3><p>在<code>source</code>目录下建立相应名称的文件夹，然后在文件夹中建立<code>index.md</code>文件，并在<code>index.md</code>的<code>front-matter</code>中设置layout为<code>layout: page</code>。若需要单栏页面，就将layout设置为 <code>layout: single-column</code>。</p><h3 id="文章评论"><a href="#文章评论" class="headerlink" title="文章评论"></a>文章评论</h3><p>文章和页面的评论功能可以通过在<code>front-matter</code>中设置<code>comments: true</code>或<code>comments: false</code>来进行开启或关闭（默认开启）。</p><h3 id="语法高亮"><a href="#语法高亮" class="headerlink" title="语法高亮"></a>语法高亮</h3><p>要启用代码高亮，请在Hexo目录的<code>_config.yml</code>中将<code>highlight</code>选项按照如下设置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">highlight:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  auto_detect:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  line_number:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  tab_replace:</span></span><br></pre></td></tr></table></figure><h3 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h3><p>要启用数学公式支持，请在Hexo目录的<code>_config.yml</code>中添加：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mathjax:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>并在相应文章的<code>front-matter</code>中添加<code>mathjax: true</code>，例如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Test</span> <span class="string">Math</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">1997</span><span class="bullet">-01</span><span class="bullet">-01</span> <span class="number">00</span><span class="string">:00:00</span></span><br><span class="line"><span class="attr">categories:</span> <span class="string">math</span></span><br><span class="line"><span class="attr">mathjax:</span> <span class="literal">true</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>数学公式的默认定界符是<code>$$...$$</code>和<code>\\[...\\]</code>（对于块级公式），以及<code>$...$</code>和<code>\\(...\\)</code>（对于行内公式）。</p><p>但是，如果你的文章内容中经常出现美元符号“<code>$</code>”, 或者说你想将“<code>$</code>”用作美元符号而非行内公式的定界符，请在Hexo目录的<code>_config.yml</code>中添加：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mathjax2:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>而不是<code>mathjax: true</code>。 相应地，在需要使用数学公式的文章的<code>front-matter</code>中也添加<code>mathjax2: true</code></p><h3 id="浏览器兼容"><a href="#浏览器兼容" class="headerlink" title="浏览器兼容"></a>浏览器兼容</h3><p><img src="/image/hexo_theme_maupassant_share_1.png" alt="浏览器兼容详情"></p><h3 id="支持语言"><a href="#支持语言" class="headerlink" title="支持语言"></a>支持语言</h3><p>目前支持简体中文（zh-CN），需其他语言支持在主题目录下<code>languages</code>，按照已有配置文件对照着规则添加<code>yml</code>配置文件即可</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Maupassant是Cho为typecho平台设计的一套响应式模板，其简洁的风格让很多人喜爱，在没有被扩展其他功能的情况下整个模板本身小巧到只有几十KB，因此访问速度也可观&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/hexo_theme_maupassant_share2.png&quot; alt=&quot;Hexo Maupassant博客主题&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="走走看看" scheme="http://sevennight.cc/categories/%E8%B5%B0%E8%B5%B0%E7%9C%8B%E7%9C%8B/"/>
    
    
      <category term="Hexo" scheme="http://sevennight.cc/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Integer与int的种种比较</title>
    <link href="http://sevennight.cc/2016/09/16/integer_and_int_compare.html"/>
    <id>http://sevennight.cc/2016/09/16/integer_and_int_compare.html</id>
    <published>2016-09-15T18:28:01.000Z</published>
    <updated>2019-01-01T04:09:41.348Z</updated>
    
    <content type="html"><![CDATA[<p>如果别人问Integer和int的区别是什么？<br>可能很多人很自然的就想到了以下两点：<br>1、Integer是int的包装类<br>2、int的初始值为0，Integer的初始值为null</p><p>但是，如果别人在问一下<br>Integer i1 = 1;<br>int i2 = 1;<br>i1==i2 为true还是false？  </p><p>Integer i3 = 1;<br>Integer i4 = 1;<br>i3==i4 为true还是false？</p><p>要求解释一下，为什么会是这个结果，可能会有一些人脑袋就有点懵，虽说这很基础，但很多人没有这么深入研究过，这里对他进行一下总结；<br><a id="more"></a></p><p>首先我们先来看一段代码</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> TestInteger &#123;</span><br><span class="line">    <span class="keyword">public</span> static void main(String[] args) &#123;</span><br><span class="line">        <span class="built_in">int</span> i1 = <span class="number">128</span>;</span><br><span class="line">        <span class="keyword">Integer</span> i2 = <span class="number">128</span>;</span><br><span class="line">        <span class="keyword">Integer</span> i3 = new <span class="keyword">Integer</span>(<span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">        //<span class="keyword">Integer</span> 和 <span class="built_in">int</span> 进行比较会自动拆箱成<span class="built_in">int</span></span><br><span class="line">        System.<span class="keyword">out</span>.println(i1 == i2); //true</span><br><span class="line">        System.<span class="keyword">out</span>.println(i1 == i3); //true</span><br><span class="line"></span><br><span class="line">        <span class="keyword">Integer</span> i4 = <span class="number">127</span>; //Java在编译的时候，被翻译成<span class="keyword">Integer</span> i4 = <span class="keyword">Integer</span>.valueOf(<span class="number">127</span>);</span><br><span class="line">        <span class="keyword">Integer</span> i5 = <span class="number">127</span>;</span><br><span class="line">        System.<span class="keyword">out</span>.println(i4 == i5); //true</span><br><span class="line"></span><br><span class="line">        <span class="keyword">Integer</span> i6 = <span class="number">128</span>;</span><br><span class="line">        <span class="keyword">Integer</span> i7 = <span class="number">128</span>;</span><br><span class="line">        System.<span class="keyword">out</span>.println(i6 == i7); //false</span><br><span class="line"></span><br><span class="line">        <span class="keyword">Integer</span> i8 = new <span class="keyword">Integer</span>(<span class="number">128</span>);</span><br><span class="line">        <span class="keyword">Integer</span> i9 = new <span class="keyword">Integer</span>(<span class="number">128</span>);</span><br><span class="line">        System.<span class="keyword">out</span>.println(i8 == i9); //false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一处，i1和i2比较，i1和i3比较，结果都为true，在JDK1.5以上，Integer和int比较都会进行自动拆箱，所以这里为true<br>第二处，i4和i5比较的时候为true，但i6和i7进行比较的时候为false，在这里就会有非常多的人不知道是为什么，这里其实跟编译有关</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Integer</span> i4 = <span class="number">127</span>;  //在Java编译的时候，被翻译成<span class="keyword">Integer</span> i4 = <span class="keyword">Integer</span>.valueOf(<span class="number">127</span>);</span><br></pre></td></tr></table></figure><p>所以，这里我们在JDK源码里面查看一下valueOf(int i);函数源码的实现</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Returns a &lt;tt&gt;Integer&lt;/tt&gt;<span class="built_in"> instance </span>representing the specified</span><br><span class="line"> * &lt;tt&gt;int&lt;/tt&gt; value.</span><br><span class="line"> * If a<span class="built_in"> new </span>&lt;tt&gt;Integer&lt;/tt&gt;<span class="built_in"> instance </span>is<span class="built_in"> not </span>required, this method</span><br><span class="line"> * should generally be used in preference to the<span class="keyword"> constructor</span></span><br><span class="line"> * &#123;@link <span class="comment">#Integer(int)&#125;, as this method is likely to yield</span></span><br><span class="line"> * significantly better space<span class="built_in"> and </span>time performance by caching</span><br><span class="line"> * frequently requested values.</span><br><span class="line"> *</span><br><span class="line"> * @param  i an &lt;code&gt;int&lt;/code&gt; value.</span><br><span class="line"> * @return a &lt;tt&gt;Integer&lt;/tt&gt;<span class="built_in"> instance </span>representing &lt;tt&gt;i&lt;/tt&gt;.</span><br><span class="line"> * @since  1.5</span><br><span class="line"> */</span><br><span class="line">public<span class="keyword"> static</span> Integer valueOf(int i) &#123;</span><br><span class="line">   <span class="keyword"> final</span><span class="built_in"> int </span>offset = 128;</span><br><span class="line">   <span class="built_in"> if </span>(i &gt;= -128 &amp;&amp; i &lt;= 127) &#123; // must cache </span><br><span class="line">       <span class="built_in"> return </span>IntegerCache.cache[i + offset];</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="built_in"> return </span>new Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在JDK的源码中，找到一段valueOf(int i);的实现代码，发现JDK在这个实现里对-128到127之间的数进行了缓存(这样对效率和空间上都比较好)，如果数值大于了127，返回的就是一个对象，而如果两边对比的都是大于127的，那么就相当于对比的两个对象，所以会为false</p><p>i8和i9不一样，为因为对象不一样，所有为false</p><p>总结：<br>1、Integer和int进行比较，不管有没有进行new，都会为true，因为会把Integer自动拆箱成int再去比<br>2、两个都是非new出来的Integer，如果数值在-128到127之前，则为true，否则为false<br>3、两个new出来的Integer进行对比，因为对象不一样会为false</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果别人问Integer和int的区别是什么？&lt;br&gt;可能很多人很自然的就想到了以下两点：&lt;br&gt;1、Integer是int的包装类&lt;br&gt;2、int的初始值为0，Integer的初始值为null&lt;/p&gt;
&lt;p&gt;但是，如果别人在问一下&lt;br&gt;Integer i1 = 1;&lt;br&gt;int i2 = 1;&lt;br&gt;i1==i2 为true还是false？  &lt;/p&gt;
&lt;p&gt;Integer i3 = 1;&lt;br&gt;Integer i4 = 1;&lt;br&gt;i3==i4 为true还是false？&lt;/p&gt;
&lt;p&gt;要求解释一下，为什么会是这个结果，可能会有一些人脑袋就有点懵，虽说这很基础，但很多人没有这么深入研究过，这里对他进行一下总结；&lt;br&gt;
    
    </summary>
    
      <category term="后台开发" scheme="http://sevennight.cc/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="java" scheme="http://sevennight.cc/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>理解clone()方法如何使用</title>
    <link href="http://sevennight.cc/2016/09/12/understand_clone_use.html"/>
    <id>http://sevennight.cc/2016/09/12/understand_clone_use.html</id>
    <published>2016-09-12T08:42:01.000Z</published>
    <updated>2019-01-01T04:09:41.359Z</updated>
    
    <content type="html"><![CDATA[<p>在实际编程过程中，我们常常要遇到这种情况：有一个对象A，在某一时刻A中已经包含了一些有效值，此时可能会需要一个和A完全相同新对象B，并且此后对B任何改动都不会影响到A中的值，也就是说，A与B是两个独立的对象，但B的初始值是由A对象确定的</p><p>于是，在这种情况下，clone就可以派的上用场了<br><a id="more"></a></p><p>Clone有缺省行为，super.clone();他负责产生正确大小的空间，并逐位复制，使用clone()来复制一个对象，clone()从Object类继承。所有具有clone功能的类都有一个特性，那就是它直接或间接地实现了Cloneable接口。</p><p>我们可以来看一看JDK的Object源码里clone接口</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> <span class="function">Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure><p>可以看出它是一个protected方法,所以我们不能简单地调用它；关键字native，表明这个方法使用java以外的语言实现</p><p>Clone的使用方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> sex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> sex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(<span class="keyword">int</span> sex)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.sex = sex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (User)<span class="keyword">super</span>.clone();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"User [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">", sex="</span> + sex + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight pony"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> u = <span class="function"><span class="keyword">new</span> <span class="title">User</span>();</span></span><br><span class="line"><span class="function"><span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span>(u.clone()!=<span class="title">u</span>);</span></span><br><span class="line"><span class="function"><span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span>(u.clone().<span class="title">getClass</span>()==<span class="title">u</span>.<span class="title">getClass</span>());</span></span><br><span class="line"><span class="function"><span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span>(u.clone().<span class="title">toString</span>().<span class="title">equals</span>(u.toString()));</span></span><br><span class="line"><span class="function">/*返回的值都为<span class="title">true</span>*/</span></span><br></pre></td></tr></table></figure><p>说明：<br>1、拷贝对象返回的是一个新对象，而不是一个引用<br>2、拷贝对象与用new操作符返回的对象区别在于这个拷贝包含了一些原来对象的信息，而不是对象的初始化信息</p><p>浅拷贝(浅克隆)和深拷贝(深克隆)的概念:<br>浅拷贝：被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。换言之，浅复制仅仅复制所考虑的对象，而不复制它所引用的对象。  </p><p>深拷贝：被复制对象的所有变量都含有与原来的对象相同的值，除去那些引用其他对象的变量。那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。换言之，深复制把要复制的对象所引用的对象都复制了一遍。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在实际编程过程中，我们常常要遇到这种情况：有一个对象A，在某一时刻A中已经包含了一些有效值，此时可能会需要一个和A完全相同新对象B，并且此后对B任何改动都不会影响到A中的值，也就是说，A与B是两个独立的对象，但B的初始值是由A对象确定的&lt;/p&gt;
&lt;p&gt;于是，在这种情况下，clone就可以派的上用场了&lt;br&gt;
    
    </summary>
    
      <category term="后台开发" scheme="http://sevennight.cc/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="java" scheme="http://sevennight.cc/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>将静态文件缓存到html5的localStorage，给网站加速</title>
    <link href="http://sevennight.cc/2016/07/30/localStorage_css_and_js.html"/>
    <id>http://sevennight.cc/2016/07/30/localStorage_css_and_js.html</id>
    <published>2016-07-30T03:06:00.000Z</published>
    <updated>2019-01-01T04:09:41.357Z</updated>
    
    <content type="html"><![CDATA[<p>html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage。sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁</p><p>本文要说的是html5的localStorage本地储存方式，localStorag可以说是cookie的一个加强版，相比localStorag来说，cookie的限制太多，限制大小4K，并在某些浏览器下还有域名限制；好的是现在html5提供的localStorag比较牛*，有5M的大小，因此爱折腾的小伙伴可以用它来做一些有意思东西</p><p>使用localStorage（本地缓存）的优缺点：<br>优点：</p><ul><li>用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的</li><li>可以通过chrome浏览器Resources/Local Storage来查看</li><li>容量大，易用，原生支持</li></ul><p>缺点：</p><ul><li>兼容性问题（IE8以下的版本不支持） </li><li>安全性问题，不适用于保存敏感的数据</li></ul><p>对于本文要做的事情就是把js和css静态文件保存到本地储存，所以在我们眼里，缺点基本上可以忽略不计<br><a id="more"></a></p><p>实现代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> whir = <span class="built_in">window</span>.whir || &#123;&#125;;</span><br><span class="line">whir.res = &#123;</span><br><span class="line">  <span class="comment">//页面版本，也由页面输出，用于刷新localStorage缓存</span></span><br><span class="line">  pageVersion: <span class="string">"0.0.1"</span>, </span><br><span class="line">  loadJs: <span class="function"><span class="keyword">function</span> (<span class="params">name, url, callback</span>) </span>&#123;<span class="comment">//动态加载js文件并缓存</span></span><br><span class="line">      <span class="comment">//判断浏览器是否支持HTML5本地储存</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">window</span>.localStorage) &#123;</span><br><span class="line">          <span class="keyword">var</span> xhr;</span><br><span class="line">          <span class="keyword">var</span> js = localStorage.getItem(name);</span><br><span class="line">          <span class="keyword">if</span> (js == <span class="literal">null</span> || js.length == <span class="number">0</span> || <span class="keyword">this</span>.pageVersion != localStorage.getItem(<span class="string">"version"</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">window</span>.ActiveXObject) &#123;</span><br><span class="line">              xhr = <span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123;</span><br><span class="line">              xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (xhr != <span class="literal">null</span>) &#123;</span><br><span class="line">              xhr.open(<span class="string">"GET"</span>, url);</span><br><span class="line">              xhr.send(<span class="literal">null</span>);</span><br><span class="line">              xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status == <span class="number">200</span>) &#123;</span><br><span class="line">                  js = xhr.responseText;</span><br><span class="line">                  localStorage.setItem(name, js);</span><br><span class="line">                  localStorage.setItem(<span class="string">"version"</span>, whir.res.pageVersion);</span><br><span class="line">                  js = js == <span class="literal">null</span> ? <span class="string">""</span> : js;</span><br><span class="line">                  whir.res.writeJs(js);</span><br><span class="line">                  <span class="keyword">if</span> (callback != <span class="literal">null</span>) &#123;</span><br><span class="line">                    callback(); <span class="comment">//回调，执行下一个引用</span></span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            whir.res.writeJs(js);</span><br><span class="line">              <span class="keyword">if</span> (callback != <span class="literal">null</span>) &#123;</span><br><span class="line">                  callback(); <span class="comment">//回调，执行下一个引用</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          whir.res.linkJs(url);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  loadCss: <span class="function"><span class="keyword">function</span> (<span class="params">name, url</span>) </span>&#123;<span class="comment">//动态加载css文件并缓存</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">window</span>.localStorage) &#123;</span><br><span class="line">          <span class="keyword">var</span> xhr;</span><br><span class="line">          <span class="keyword">var</span> css = localStorage.getItem(name);</span><br><span class="line">          <span class="keyword">if</span> (css == <span class="literal">null</span> || css.length == <span class="number">0</span> || <span class="keyword">this</span>.pageVersion != localStorage.getItem(<span class="string">"version"</span>)) &#123;</span><br><span class="line">              <span class="keyword">if</span> (<span class="built_in">window</span>.ActiveXObject) &#123;</span><br><span class="line">                  xhr = <span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123;</span><br><span class="line">                  xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (xhr != <span class="literal">null</span>) &#123;</span><br><span class="line">                  xhr.open(<span class="string">"GET"</span>, url);</span><br><span class="line">                  xhr.send(<span class="literal">null</span>);</span><br><span class="line">                  xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                      <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status == <span class="number">200</span>) &#123;</span><br><span class="line">                          css = xhr.responseText;</span><br><span class="line">                          localStorage.setItem(name, css);</span><br><span class="line">                          localStorage.setItem(<span class="string">"version"</span>, whir.res.pageVersion);</span><br><span class="line">                          css = css == <span class="literal">null</span> ? <span class="string">""</span> : css;</span><br><span class="line">                           css = css.replace(<span class="regexp">/\..\/img\//g</span>,+<span class="string">"http://www.test.com/img/"</span>); <span class="comment">//css里的img路径需单独处理</span></span><br><span class="line">                          whir.res.writeCss(css);</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              whir.res.writeCss(css);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          whir.res.linkCss(url);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//往页面写入js脚本</span></span><br><span class="line">  writeJs: <span class="function"><span class="keyword">function</span> (<span class="params">text</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> head = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'HEAD'</span>).item(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">var</span> link = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span><br><span class="line">      link.type = <span class="string">"text/javascript"</span>;</span><br><span class="line">      link.innerHTML = text;</span><br><span class="line">      head.appendChild(link);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//往页面写入css样式</span></span><br><span class="line">  writeCss: <span class="function"><span class="keyword">function</span> (<span class="params">text</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> head = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'HEAD'</span>).item(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">var</span> link = <span class="built_in">document</span>.createElement(<span class="string">"style"</span>);</span><br><span class="line">      link.type = <span class="string">"text/css"</span>;</span><br><span class="line">      link.innerHTML = text;</span><br><span class="line">      head.appendChild(link);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//往页面引入js脚本</span></span><br><span class="line">  linkJs: <span class="function"><span class="keyword">function</span> (<span class="params">url</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> head = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'HEAD'</span>).item(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">var</span> link = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span><br><span class="line">      link.type = <span class="string">"text/javascript"</span>;</span><br><span class="line">      link.src = url;</span><br><span class="line">      head.appendChild(link);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//往页面引入css样式</span></span><br><span class="line">  linkCss: <span class="function"><span class="keyword">function</span> (<span class="params">url</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> head = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'HEAD'</span>).item(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">var</span> link = <span class="built_in">document</span>.createElement(<span class="string">"link"</span>);</span><br><span class="line">      link.type = <span class="string">"text/css"</span>;</span><br><span class="line">      link.rel = <span class="string">"stylesheet"</span>;</span><br><span class="line">      link.rev = <span class="string">"stylesheet"</span>;</span><br><span class="line">      link.media = <span class="string">"screen"</span>;</span><br><span class="line">      link.href = url;</span><br><span class="line">      head.appendChild(link);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>因为每当静态文件储存到了本地缓存之后，之后除非是手动删除不然就会一直存在，上面的代码在读取了一次之后，以后再次加载的时候就不会再去加载，而是直接去本地储存里读取，所以如果当css或js静态文件有改动的时候需要更改版本号，就需要手动更改<code>pageVersion</code>版本号参数</p><p><strong>页面加载及添加js缓存调用方法</strong><br>参数：[缓存名称，文件加载路径，回调方法(可选)]</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whir.res.loadJs(<span class="string">"jquery.js"</span>, <span class="string">"//cdn.bootcss.com/jquery/1.12.4/jquery.min.js"</span>,<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>还有另外一种加载情景，由于js加载有顺序要求，所以需要将后加载的脚本作为前一个脚本的回调参数传入，不然可能会出现有的js脚本需要jquery的支持，但在jquery加载之前执行了，会因为jquery未加载完而报错</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">whir.res.loadJs(<span class="string">"jquery"</span>, <span class="string">"//cdn.bootcss.com/jquery/1.12.4/jquery.min.js"</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    whir.res.loadJs(<span class="string">"index.js"</span>, <span class="string">"script/index.js"</span>, <span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>页面加载及添加css缓存调用方法</strong><br>参数：[缓存名称，文件加载路径]</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whir.res.loadCss(<span class="string">"css"</span>, <span class="string">"/style/style.css"</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p><font color="red">注：</font>在加载网络静态文件的时候，会容易出现相对路径加载不正确的情况，例如图片、字体文件，因为加载到本地储存就相当于这个文件变成了当前网站本地的css文件，与网络文件已经无关了，但里面的相对路径也是基于当前网站进行读取文件，而网络文件是基于他自己域名进行获取的路径，所以会加载失败，因此在css文件加载完成之后需要对相对路径做特殊处理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//css里的img路径需单独处理</span></span><br><span class="line"><span class="keyword">var</span> css = <span class="string">"--css代码--"</span>;</span><br><span class="line">css.replace(<span class="regexp">/\..\/img\//g</span>,+<span class="string">"http://www.test.com/img/"</span>);</span><br></pre></td></tr></table></figure><p>用加入本地缓存的方法把静态文件缓存到本地，可以大大的提高网站的响应速度，在网站css和js要加载很多的情况下，加入到本地缓存也是一个不错的方法，从几十个请求，可以立马变成几个请求，唯一需要注意的就是对于网络路径和第一次脚本的加载顺序、效果方面需要费心做一下处理，对于小站点和个人博客来说用这种方法挺好的</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage。sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁&lt;/p&gt;
&lt;p&gt;本文要说的是html5的localStorage本地储存方式，localStorag可以说是cookie的一个加强版，相比localStorag来说，cookie的限制太多，限制大小4K，并在某些浏览器下还有域名限制；好的是现在html5提供的localStorag比较牛*，有5M的大小，因此爱折腾的小伙伴可以用它来做一些有意思东西&lt;/p&gt;
&lt;p&gt;使用localStorage（本地缓存）的优缺点：&lt;br&gt;优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的&lt;/li&gt;
&lt;li&gt;可以通过chrome浏览器Resources/Local Storage来查看&lt;/li&gt;
&lt;li&gt;容量大，易用，原生支持&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;兼容性问题（IE8以下的版本不支持） &lt;/li&gt;
&lt;li&gt;安全性问题，不适用于保存敏感的数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于本文要做的事情就是把js和css静态文件保存到本地储存，所以在我们眼里，缺点基本上可以忽略不计&lt;br&gt;
    
    </summary>
    
      <category term="前端开发" scheme="http://sevennight.cc/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="javascript" scheme="http://sevennight.cc/tags/javascript/"/>
    
      <category term="html5" scheme="http://sevennight.cc/tags/html5/"/>
    
  </entry>
  
  <entry>
    <title>使用token实现在有效期内APP自动登录功能</title>
    <link href="http://sevennight.cc/2016/07/19/auto_login_impl.html"/>
    <id>http://sevennight.cc/2016/07/19/auto_login_impl.html</id>
    <published>2016-07-19T09:20:35.000Z</published>
    <updated>2019-01-01T04:09:41.342Z</updated>
    
    <content type="html"><![CDATA[<p>实现此功能的场景是在当下用户对手机APP体验要求高，并且相对安全前提的推动下诞生；当你下载了一个QQ，微信第一次进行了账号和密码的登录，你从此以后打开应用免去了你每日打开应用都要输入账号跟密码的痛苦过程，在产品体验方面来讲，这种体验更为让用户容易接受。那么，这种自动登录如何实现；</p><p>之前在APP里面接入达达配送的时候，看到他们提供的API接口里面大致有了这个一个认证的过程，自己琢磨了一下，依稀的弄出了一个类似这样的自动登录的流程；</p><h3 id="一、获取token登录令牌接口（可以理解为登录接口）"><a href="#一、获取token登录令牌接口（可以理解为登录接口）" class="headerlink" title="一、获取token登录令牌接口（可以理解为登录接口）"></a>一、获取token登录令牌接口（可以理解为登录接口）</h3><p>这一步是需要用户使用账号和密码进行登录去获取，用户如果登录成功，那么后台返回一个token及token的失效时间，及未来如果token失效之后刷新token的令牌！</p><p>返回参数示例及说明：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">//状态位，ok表示成功</span></span><br><span class="line">  <span class="string">"status"</span>: <span class="string">"0"</span>,  </span><br><span class="line">  <span class="comment">//申请的有效token值</span></span><br><span class="line">  <span class="string">"token"</span>: <span class="string">"4a28d8516d42f4821e6d5782d1a79a7a"</span>,  </span><br><span class="line">  <span class="comment">//token的有效时间,单位为秒，这里设定7天有效期（604800秒）</span></span><br><span class="line">  <span class="string">"expires_in"</span>: <span class="string">"604800"</span>, </span><br><span class="line">  <span class="comment">//token过期情况下，用来刷新access_token值,设置30天的有效期</span></span><br><span class="line">  <span class="string">"refresh_token"</span>: <span class="string">"8ab486662d50e6d51a5a5dd6a25c9a4b"</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>用户第一次进入APP，APP判断手机上是否存在token值，不存在，表明用户第一次进入APP，跳转登录界面让用户进行登录</li><li>用户使用账号和密码登录成功，后台进行认证，认证成功，返回token、expires_in、refresh_token，APP需把这几个值安全保存在手机本地，便于下一次用户进入app的一些流程判断</li><li>继续上一步中间插入一个小细节，后台在登录成功之后，需要把token、expires_in、refresh_token（其他附加值：如设备唯一编号、或其他密令…）保存在数据库和用户关联的表里，便于未来用户自动登录认证使用</li><li>上面步骤进行完毕，APP即跳入到应用首页，用户可以完全使用APP</li></ul><h3 id="二、刷新token登录令牌接口"><a href="#二、刷新token登录令牌接口" class="headerlink" title="二、刷新token登录令牌接口"></a>二、刷新token登录令牌接口</h3><p>此接口是对第一个接口的一些弥补，token的过期时间原理上可以说是越短越安全，那么存在的问题就是token有一个过期时间，那么过期之后是不可能让用户重新输入用户名和密码来重新获取token的，那样完全违背了提升体验的初衷，相当于此功能是一个累赘了；</p><p>在token过期的情况，我们可以使用保存在手机本地的refresh_token去后台刷新一下token，重新获取一组令牌信息，覆盖掉以前保存在手机上的令牌信息，这也算是提升了一点安全性，为避免以前的令牌信息如果真落入别人之手；</p><p>此接口的请求参数可以参考以下参数：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">//用户账号，大多数APP用的是手机号登录，这里也可以是其他值，能表名是将要自动登录的用户即可</span></span><br><span class="line">  <span class="string">"username"</span>: <span class="string">"13000000007"</span>, </span><br><span class="line">  <span class="comment">//手机设备的唯一值</span></span><br><span class="line">  <span class="string">"imei"</span>: <span class="string">"928347024892343"</span>,</span><br><span class="line">  <span class="comment">//刷新token的令牌</span></span><br><span class="line">  <span class="string">"refresh_token"</span>: <span class="string">"8ab486662d50e6d51a5a5dd6a25c9a4b"</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回参数示例及说明：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">//状态位，ok表示成功</span></span><br><span class="line">  <span class="string">"status"</span>: <span class="string">"0"</span>,  </span><br><span class="line">  <span class="comment">//申请的有效token值</span></span><br><span class="line">  <span class="string">"token"</span>: <span class="string">"4a28d8516d42f4821e6d5782d1a79a7a"</span>,  </span><br><span class="line">  <span class="comment">//token的有效时间,单位为秒，这里设定7天有效期（604800秒）</span></span><br><span class="line">  <span class="string">"expires_in"</span>: <span class="string">"604800"</span>,  </span><br><span class="line">  <span class="comment">//token过期情况下，用来刷新access_token值,设置30天的有效期</span></span><br><span class="line">  <span class="string">"refresh_token"</span>: <span class="string">"8ab486662d50e6d51a5a5dd6a25c9a4b"</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：<br>看着是不是和获取token的接口返回值一样，对，你没有看错，这确实就是和获取token的接口是一样的，把返回的这些令牌信息覆盖掉之前保存在手机上的老的令牌信息就可以了；特别是这里为了节省请求接口的次数，刷新token成功之后就可以让用户跳转到首页进行使用app了，不用再次请求其他认证token的接口了</p><p>从请求到响应之后的一系列处理流程为：</p><ul><li>场景是用户过了1天之后再次打开了APP，APP首先获取本地是否存在token，如存在，会去请求第三步的token认证接口，需要用到刷新token这个接口的前提必须是token认证接口的返回值表示token过期了，那么此时本接口（刷新登录令牌的接口就有了作用），这里可以使用账号、设备编号、刷新token的令牌或者你还可以自己定一些加密方案的参数一同传入后台进行认证，当后台认证此刷新令牌（refresh_token）有效且合法，那么重新生成一组令牌保存在数据库，同时返回这一组令牌到APP（这一组令牌全部都是需要重新生成，并且过期时间重新全部初始化）</li><li>APP同样把成功响应的一组令牌值覆盖掉以前保存在本地的令牌值</li><li>成功的情况，此时，可以让用户跳转到首页让用户使用APP</li><li>失败的情况，如refresh_token也过期了，这里特别说一下，一般refresh_token的过期时间是比较长的，如果连这个也过期的话，说明用户已经太久没有使用过APP了，需要让用户重新登录</li></ul><h3 id="三、token认证接口（可理解为自动登录接口）"><a href="#三、token认证接口（可理解为自动登录接口）" class="headerlink" title="三、token认证接口（可理解为自动登录接口）"></a>三、token认证接口（可理解为自动登录接口）</h3><p>此接口相当而言算是请求频率比较多的一个接口，他对token进行认证成功和失败有不同的处理方式；</p><p>此接口的请求参数可以参考以下参数：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">//用户账号，大多数APP用的是手机号登录，这里也可以是其他值，能表名是将要自动登录的用户即可</span></span><br><span class="line">  <span class="string">"username"</span>: <span class="string">"13000000007"</span>,</span><br><span class="line">  <span class="comment">//手机设备的唯一值</span></span><br><span class="line">  <span class="string">"imei"</span>: <span class="string">"928347024892343"</span>,  </span><br><span class="line">  <span class="comment">//token认证令牌</span></span><br><span class="line">  <span class="string">"token"</span>: <span class="string">"4a28d8516d42f4821e6d5782d1a79a7a"</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回参数示例及说明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"status"</span>: <span class="string">"0"</span>  <span class="comment">//响应结果，成功</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">or</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"status"</span>: <span class="string">"1"</span>  <span class="comment">//响应结果，token过期</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>这里如果返回成功，可以让用户跳转到首页使用APP</li><li>如果返回token过期，调用第二步的刷新token令牌的接口去重新获取令牌</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;实现此功能的场景是在当下用户对手机APP体验要求高，并且相对安全前提的推动下诞生；当你下载了一个QQ，微信第一次进行了账号和密码的登录，你从此以后打开应用免去了你每日打开应用都要输入账号跟密码的痛苦过程，在产品体验方面来讲，这种体验更为让用户容易接受。那么，这种自动登录如何
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://sevennight.cc/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="程序设计" scheme="http://sevennight.cc/tags/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式之 - 单例模式</title>
    <link href="http://sevennight.cc/2015/11/12/java_design_pattern_singleton.html"/>
    <id>http://sevennight.cc/2015/11/12/java_design_pattern_singleton.html</id>
    <published>2015-11-12T09:43:01.000Z</published>
    <updated>2019-01-01T04:09:41.350Z</updated>
    
    <content type="html"><![CDATA[<p>单例模式（Singleton Pattern）是Java中最简单的设计模式之一，这种类型的设计模式属于“创建者”模式  </p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>概述：单例模式的意思就是只有一个实例。单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。这个类称为单例类<br>作用：Singleton模式主要作用是保证在Java应用程序中，一个类Class只有一个实例存在<br>注意点：构造函数是私有的，避免外界利用构造方法直接创建出实例<br>使用场景：</p><ul><li>1、要求生成唯一的序列号</li><li>2、web中的计数器，不用常去数据库更新，可以先用单例缓存起来</li><li>3、创建对象比较耗资源的操作，比如 I/O 与数据库的连接</li><li>4、web中的共享的资源配置对象读取也可以用单例<br>等等……</li></ul><a id="more"></a><p>优点：</p><ul><li>1、节省内存开销，限制了实例的个数，不用频繁去创建</li></ul><p>缺点： </p><ul><li>1、单例模式没有抽象层，不易扩展</li><li>2、单例类的职责过重，在一定程度上违背了“单一职责原则”。因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起。</li><li>3、滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；现在很多面向对象语言（如Java、C#）的运行环境都提供了自动垃圾回收的技术，因此，如果实例化的对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致对象状态的丢失。</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>Singleton的实现有多种方式，一般单例都是五种写法。饿汉，懒汉，双重校验锁，枚举和静态内部类。</p><p>1、饿汉</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EagerSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> EagerSingleton singleton = <span class="keyword">new</span> EagerSingleton();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EagerSingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EagerSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、懒汉</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton singleton = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、双重检查锁定（算是懒汉式的一种改进）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、枚举</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EnumSingleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whateverMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、静态内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInsideClassSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> StaticInsideClassSingleton instance = <span class="keyword">new</span> StaticInsideClassSingleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StaticInsideClassSingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> StaticInsideClassSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整理途中参考的一些文章<br><a href="http://www.cnblogs.com/ykt/archive/2011/11/24/2261251.html" target="_blank" rel="noopener">http://www.cnblogs.com/ykt/archive/2011/11/24/2261251.html</a><br><a href="http://www.oschina.net/code/snippet_107039_6062" target="_blank" rel="noopener">http://www.oschina.net/code/snippet_107039_6062</a><br><a href="http://www.tuicool.com/articles/NVza2am" target="_blank" rel="noopener">http://www.tuicool.com/articles/NVza2am</a><br><a href="http://www.blogjava.net/kenzhh/archive/2016/03/28/357824.html" target="_blank" rel="noopener">http://www.blogjava.net/kenzhh/archive/2016/03/28/357824.html</a>  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;单例模式（Singleton Pattern）是Java中最简单的设计模式之一，这种类型的设计模式属于“创建者”模式  &lt;/p&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;概述：单例模式的意思就是只有一个实例。单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。这个类称为单例类&lt;br&gt;作用：Singleton模式主要作用是保证在Java应用程序中，一个类Class只有一个实例存在&lt;br&gt;注意点：构造函数是私有的，避免外界利用构造方法直接创建出实例&lt;br&gt;使用场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1、要求生成唯一的序列号&lt;/li&gt;
&lt;li&gt;2、web中的计数器，不用常去数据库更新，可以先用单例缓存起来&lt;/li&gt;
&lt;li&gt;3、创建对象比较耗资源的操作，比如 I/O 与数据库的连接&lt;/li&gt;
&lt;li&gt;4、web中的共享的资源配置对象读取也可以用单例&lt;br&gt;等等……&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="后台开发" scheme="http://sevennight.cc/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="java" scheme="http://sevennight.cc/tags/java/"/>
    
      <category term="设计模式" scheme="http://sevennight.cc/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>构造器Constructor是否可被Override？</title>
    <link href="http://sevennight.cc/2015/11/01/constructor_whether_can_override.html"/>
    <id>http://sevennight.cc/2015/11/01/constructor_whether_can_override.html</id>
    <published>2015-10-31T17:03:01.000Z</published>
    <updated>2019-01-01T04:09:41.344Z</updated>
    
    <content type="html"><![CDATA[<p>构造器Constructor不能被继承，所以不能被重写，不过他可以被重载Overload</p><p>钻了一个牛角尖，构造器为什么不能被继承呢？<br>在解释构造器Constructor为什么不能被继承和重写之前，我们先来了解构造器的概念。构造器在程序语言中是为了创建一个类的实例，如：Student stu1= new Student()，这就是创建了一个类的实例，同时也生成了一个构造器。构造器也分为有参数的和无参数的，上面的例子是无参的，Student stu2 = new Student(“李四”,28)，这是有参的构造器。<br><a id="more"></a></p><p>那为什么说构造器Constructor为什么不能被继承和重写呢？</p><p>因为“重写”只能发生在“继承”或“接口”这个两个概念上。我们可以以动物来举例，如果我们声明的这个动物用了new语句，这时我们就创建了一个实实在在的动物出来了，那么这个动物是独立存在的，是一个体，一个独立存在的的动物当然不能够被继承。但是对于类在没有实体化之前就是一个抽象的概念，那么就可以被继承。</p><p>如果还不能被理解，对于有一些钻牛角尖的人还需要问为什么的话，可以有一个很牛B的回答：你和你爸爸这是实体，独立存在的，那么就是一个构造器，如果构造器可以继承的话，那么，你爸爸、你爷爷、你、甚至往上，这些所有的人都完全一样的了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;构造器Constructor不能被继承，所以不能被重写，不过他可以被重载Overload&lt;/p&gt;
&lt;p&gt;钻了一个牛角尖，构造器为什么不能被继承呢？&lt;br&gt;在解释构造器Constructor为什么不能被继承和重写之前，我们先来了解构造器的概念。构造器在程序语言中是为了创建一个类的实例，如：Student stu1= new Student()，这就是创建了一个类的实例，同时也生成了一个构造器。构造器也分为有参数的和无参数的，上面的例子是无参的，Student stu2 = new Student(“李四”,28)，这是有参的构造器。&lt;br&gt;
    
    </summary>
    
      <category term="后台开发" scheme="http://sevennight.cc/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="java" scheme="http://sevennight.cc/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java三大特性之多态</title>
    <link href="http://sevennight.cc/2014/10/25/java_polymorphism_understand.html"/>
    <id>http://sevennight.cc/2014/10/25/java_polymorphism_understand.html</id>
    <published>2014-10-25T04:30:01.000Z</published>
    <updated>2019-01-01T04:09:41.355Z</updated>
    
    <content type="html"><![CDATA[<p>面向对象编程有三大特性：封装、继承、多态。  </p><p>封装隐藏了类的内部实现机制，可以在不影响使用情况下改变类的内部结构，同时也保护了数据，对于外界而言他的内部细节是隐藏的，暴露给外界的只是他的访问方法</p><p>继承所描述的是<code>“is-a”</code>（是一个，说明该类是某类的一个特殊例子）的关系，如果有两个对象A和B，若可以描述为“A是B”，则可以表示 A 继承 B，其中 B 是被继承者称之为父类或者超类，A 是继承者称之为子类或者派生类。</p><p>多态成立的三个条件<br>1.继承<br>2.子类重写父类方法<br>3.父类引用指向子类对象<br>用简述的话说就是：继承、重写、向上转型</p><p>从某一个角度来讲，封装和继承都相当于是为多态而做准备<br>多态应用的一大前提是继承，以及继承里面的重写方法；继承的一大前提是封装，及封装里面涉及到重要知识点方法重载<br><a id="more"></a></p><h2 id="那么到底什么是多态呢？它的实现机制又是什么？"><a href="#那么到底什么是多态呢？它的实现机制又是什么？" class="headerlink" title="那么到底什么是多态呢？它的实现机制又是什么？"></a>那么到底什么是多态呢？它的实现机制又是什么？</h2><blockquote><p>多态用一句话概括可以描述为：事物在运行过程中存在不同的状态；他的重要特性：一个接口，多种实现；指在编译时引用变量调用的方法无法确定是执行A类里面的方法还是B类里面的方法，只有在运行期间才能确定要执行的方法，这样不用修改源代码，就可以改变程序运行时所绑定的具体代码，让程序有多个状态可以选择，这就是多态性</p></blockquote><p>举个可爱的、形象的例子，比如有一个函数方法是对描述动物的特征，方法要求传递的参数要求是动物，但我们并不知道到底是何种动物，只有听着声音才能判断这是什么动物，听到“瞄”叫声，发现这是猫、听到“旺”叫声，发现这是狗、听到“咩”叫声，发现这是羊，于是可以描述成这样：</p><p>动物a = 猫<br>动物b = 狗<br>动物c = 羊</p><p>这里猫、狗、羊都是动物的子类，我们可以通过动物这个父类就能够引用到不同的子类，这就是多态；只有在运行的时候才会知道应用变量所指向的具体对象</p><p>由上面的例子可以看出，猫(Cat)、狗(Dog)、羊(Sheep)是动物(Animal)的子类，把Animal指向Cat对象。因为Cat是继承的Animal对象，所以Cat可以转为Animal；这样做的好处就是因为子类继承自父类，所以他可以提供比父类更强大的功能，我们定义了一个指向子类的父类引用类型，他除了能引用父类的方法外，还可以使用子类的强大功能，我们把这样的描述称为向上转型</p><p>向上转型需要注意的是父类类型的引用只能调用父类中定义的属性和方法，对于只存在子类的方法和属性他就不能调用了，即调用的方法和属性需是在超类中存在的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Animal fun1 ... "</span>);</span><br><span class="line">        fun2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Animal fun2 ... "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Cat</span><span class="params">()</span> extends Animal</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 子类重载父类的方法</span></span><br><span class="line"><span class="comment">     * 父类中不存在该方法，向上转型后，父类并不能调用该方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Cat fun1 ... "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 子类重写父类的方法</span></span><br><span class="line"><span class="comment"> * 指向子类的父类引用调用fun2时，必定会调用此方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Cat fun2 ... "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">Animal fun1 ... </span><br><span class="line">Cat fun2 ...</span><br></pre></td></tr></table></figure><p>上面的结果由于子类重载了父类的fun1()方法，重写了fun2()方法，重载后的fun1(String s)和fun1()不是同一个方法，父类中由于没有过该方法，向上转型后，丢失了fun1(String s)方法，就执行的父类的fun1()，调用fun2()方法的时候，由于子类重写的fun2()，是能调用到子类的fun2()的</p><p>多态定义上就是要通过统一、抽象的形式去完成复杂多变的需求，比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">animal.features();</span><br></pre></td></tr></table></figure><p>animal是不同的，但是属于一个派生系，features形式上是相同的，但实现不同，具体定位到哪个实现由animal的本质决定，这对于jvm来说已经非常清楚了，动态加载，动态绑定，简单粗暴的一句话就是调用了相同的方法，出现了不同的结果，这就是多态的表现</p><p>总结：因为有向上转型，所以指向子类的父类引用，只能调用父类里面存在的方法和属性；子类重写父类的方法，必定能被父类引用调用</p><p>多态有两种实现形式：继承和接口<br>上面的例子描述的就是继承的实现，那么接口的实现是怎样的呢？  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义接口InterA  </span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InterA</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//实现接口InterA的类B  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">InterA</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;      </span><br><span class="line">        System.out.println(<span class="string">"This is B"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//实现接口InterA的类C  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">InterA</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span>  </span>&#123;      </span><br><span class="line">        System.out.println(<span class="string">"This is C"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </span><br><span class="line">        InterA a;  </span><br><span class="line">        a= <span class="keyword">new</span> B();  </span><br><span class="line">        a.fun();   </span><br><span class="line">        a = <span class="keyword">new</span> C();   </span><br><span class="line">        a.fun();   </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">输出结果为：</span><br><span class="line">This is B</span><br><span class="line">This is C</span><br></pre></td></tr></table></figure><p>上例中，B类和C类是InterA接口的实现类，分别实现了接口fun()，通过将B类和C类的实例赋给接口引用a实现了方法在运行时动态绑定，也满足了“一个接口，多种实现”的特性，展出出了java的多态性</p><p>总结：同继承实现相似，java在利用接口调用实现类的方法的时候，该方法也必须是在接口中存在，并在实现类中被重写；</p><p>对比继承和接口两种实现形式，继承由于是单继承，但接口可以多实现，所以在进行扩展的时候，接口相比继承的方式有更好的灵活性</p><p>通过一个实例巩固下，这个实例包含了太多的知识，是关于多态的一个非常经典的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">show</span><span class="params">(D obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">"A and D"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">show</span><span class="params">(A obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">"A and A"</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">show</span><span class="params">(B obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">"B and B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">show</span><span class="params">(A obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">"B and A"</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">extends</span> <span class="title">B</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a1 = <span class="keyword">new</span> A();</span><br><span class="line">        A a2 = <span class="keyword">new</span> B();</span><br><span class="line">        B b = <span class="keyword">new</span> B();</span><br><span class="line">        C c = <span class="keyword">new</span> C();</span><br><span class="line">        D d = <span class="keyword">new</span> D();</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"1--"</span> + a1.show(b));</span><br><span class="line">        System.out.println(<span class="string">"2--"</span> + a1.show(c));</span><br><span class="line">        System.out.println(<span class="string">"3--"</span> + a1.show(d));</span><br><span class="line">        System.out.println(<span class="string">"4--"</span> + a2.show(b));</span><br><span class="line">        System.out.println(<span class="string">"5--"</span> + a2.show(c));</span><br><span class="line">        System.out.println(<span class="string">"6--"</span> + a2.show(d));</span><br><span class="line">        System.out.println(<span class="string">"7--"</span> + b.show(b));</span><br><span class="line">        System.out.println(<span class="string">"8--"</span> + b.show(c));</span><br><span class="line">        System.out.println(<span class="string">"9--"</span> + b.show(d));      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例实例输出的最终结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>--A and A</span><br><span class="line"><span class="number">2</span>--A and A</span><br><span class="line"><span class="number">3</span>--A and D</span><br><span class="line"><span class="number">4</span>--B and A</span><br><span class="line"><span class="number">5</span>--B and A</span><br><span class="line"><span class="number">6</span>--A and D</span><br><span class="line"><span class="number">7</span>--B and B</span><br><span class="line"><span class="number">8</span>--B and B</span><br><span class="line"><span class="number">9</span>--A and D</span><br></pre></td></tr></table></figure><p>先看比较好理解的1、2、3，①会到A类去找，但由于没发现B类型，B类型向上转型为A，最终执行的效果就是a1.show(A obj);②同理也是到A类去找，由于没有发现C类型，也是由C向上转型为A，最终执行效果同①类似，打印都是“A and A”，③这里直接A类能找到直接打印</p><p>但遇到第④个就相对有点模糊了，很多人认为是“B and B”，但事实不是，这里会涉及到多态的两个知识点<br>1、当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。<br>2、方法调用的优先问题 ，优先级由高到低依次为：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)</p><p>对于④来说，a2.show(b)，类型为A，则this为a2，b是B的一个实例，于是到A里面去找show(B obj)方法，没有找到，于是到A的super(超类)找，A由于没有超类，转到this.show((super)O)优先级查找，this还是为a2，O为B，(super)O即(super)B，翻译一下就是(A)B，其实就是转成了A，所以最后是在A里面去找show(A obj)方法，发现有了这个方法，但这儿还没有完，涉及到上面的知识点1，“被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的”，这里引用变量是A类型，引用对象是B，所以是按照引用对象来确定调用的是谁的方法，就是调用的B类里的show(A obj)，但条件是知识点中的“被调用的方法必须是在超类中定义过的”条件要满足才行，因为这里show(A obj) 也是在超类(A)里面被定义过的，所以最终打印的是“B and A”</p><p>依照此原理可以用这种方法推断其他答案</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;面向对象编程有三大特性：封装、继承、多态。  &lt;/p&gt;
&lt;p&gt;封装隐藏了类的内部实现机制，可以在不影响使用情况下改变类的内部结构，同时也保护了数据，对于外界而言他的内部细节是隐藏的，暴露给外界的只是他的访问方法&lt;/p&gt;
&lt;p&gt;继承所描述的是&lt;code&gt;“is-a”&lt;/code&gt;（是一个，说明该类是某类的一个特殊例子）的关系，如果有两个对象A和B，若可以描述为“A是B”，则可以表示 A 继承 B，其中 B 是被继承者称之为父类或者超类，A 是继承者称之为子类或者派生类。&lt;/p&gt;
&lt;p&gt;多态成立的三个条件&lt;br&gt;1.继承&lt;br&gt;2.子类重写父类方法&lt;br&gt;3.父类引用指向子类对象&lt;br&gt;用简述的话说就是：继承、重写、向上转型&lt;/p&gt;
&lt;p&gt;从某一个角度来讲，封装和继承都相当于是为多态而做准备&lt;br&gt;多态应用的一大前提是继承，以及继承里面的重写方法；继承的一大前提是封装，及封装里面涉及到重要知识点方法重载&lt;br&gt;
    
    </summary>
    
      <category term="后台开发" scheme="http://sevennight.cc/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="java" scheme="http://sevennight.cc/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java三大特性之封装</title>
    <link href="http://sevennight.cc/2014/10/24/java_encapsulation_understand.html"/>
    <id>http://sevennight.cc/2014/10/24/java_encapsulation_understand.html</id>
    <published>2014-10-24T08:42:01.000Z</published>
    <updated>2019-01-01T04:09:41.351Z</updated>
    
    <content type="html"><![CDATA[<p>封装是一种可以使类中的字段私有并能通过公有方法来访问私有字段的技术。如果一个字段被声明为私有（private），它就不能在类的外部被访问，从而隐藏了类内部的字段。基于这个原因，封装有时也被称为“数据隐藏”。</p><p>封装可以被认为是一种能够保护代码和数据被定义在类外的其它代码任意访问的屏障。访问数据和代码由一个接口严格控制。 封装的主要好处是修改我们实现的代码而又不会破坏其他人使用我们的代码。封装的这个特性使我们的代码具有可维护性、灵活性以及扩展性。 –摘自：维基百科</p><a id="more"></a><h2 id="封装的优点"><a href="#封装的优点" class="headerlink" title="封装的优点"></a>封装的优点</h2><ul><li>1、良好的封装能够减少耦合。</li><li>2、类内部的结构可以自由修改。</li><li>3、可以对成员变量进行更精确的控制。</li><li>4、隐藏信息，实现细节。</li></ul><h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><p>1、修改属性的可见性来限制属性的访问，这就要得益于java中private、protected、public各种修饰符的访问权限了，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中，把name和age用private修饰符设置为私有的，只有本类才能访问，其他的类都访问不了，这样相当于实现了上述摘要里面所说的“数据隐藏”<br>2、对属性值提供对外的公共访问方法，创建一对赋值、取值方法，作用于访问私有属性，例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>采用 this 关键字是为了解决实例变量（private String name）和局部变量（setName(String name)中的name变量）之间发生的同名的冲突。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>创建一个Man类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//属性封装，男人有姓名、年龄、妻子皆为这个对象的私有属性</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Woman wife;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 方法封装</span></span><br><span class="line"><span class="comment">     * 对该对象提供外界访问方法的封装，可以设定姓名、年龄、妻子，也可以获取姓名和年龄</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWife</span><span class="params">(Woman wife)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.wife = wife;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个Woman类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//属性封装</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Man husband;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法封装</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Man <span class="title">getHusband</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> husband;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHusband</span><span class="params">(Man husband)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.husband = husband;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以封装就是可以把一个对象的属性私有，而提供一些可以被外界访问的方法，以上实例中public方法是外部类访问该类成员变量的入口。</p><p>以Man类的name属性为例，他有get和set方法，get即为获取值，set即为赋值，用的public修饰符修饰，可以被外界所访问，在比如说Man的wife属性，就没有ge方法，男人都想金屋藏娇，外界是不能获取到wife属性的</p><p>问题继续，上面的例子还无法详细表现出封装的特性，封装的主要好处是修改我们实现的代码而又不会破坏其他人使用我们的代码，用一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(age&gt;<span class="number">200</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">"年龄输入过大！"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例中就是一个对封装特性的一个很好的表现，在输入年龄的时候不小心输入200岁的人妖就可以进入到判断里面给人提示出来了，调用者还是使用的Woman.getAge()来调用获取age值的，没有修改任何代码，但我们在在getAge()方法里面可以有一些扩展，不用担心会造成多处更改的情况，相对维护性来说，非常方便</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;封装是一种可以使类中的字段私有并能通过公有方法来访问私有字段的技术。如果一个字段被声明为私有（private），它就不能在类的外部被访问，从而隐藏了类内部的字段。基于这个原因，封装有时也被称为“数据隐藏”。&lt;/p&gt;
&lt;p&gt;封装可以被认为是一种能够保护代码和数据被定义在类外的其它代码任意访问的屏障。访问数据和代码由一个接口严格控制。 封装的主要好处是修改我们实现的代码而又不会破坏其他人使用我们的代码。封装的这个特性使我们的代码具有可维护性、灵活性以及扩展性。 –摘自：维基百科&lt;/p&gt;
    
    </summary>
    
      <category term="后台开发" scheme="http://sevennight.cc/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="java" scheme="http://sevennight.cc/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java三大特性之继承</title>
    <link href="http://sevennight.cc/2014/10/24/java_extends_understand.html"/>
    <id>http://sevennight.cc/2014/10/24/java_extends_understand.html</id>
    <published>2014-10-23T17:30:01.000Z</published>
    <updated>2019-01-01T04:09:41.353Z</updated>
    
    <content type="html"><![CDATA[<p>Java继承是面向对象的最显著的一个特征。继承是从已有的类中派生出新的类，新的类能吸收已有类的数据属性和行为，并能扩展新的能力</p><p>在多个类中存在相同属性和行为时，将这些内容单独抽取到一个类中，那么多个类就不需再次定义这些类和属性，只要继承那个类就行了</p><p>在继承的关系里，被继承的类称为父类、超类或者基类，而继承的类就被称为子类。子类继承了父类的所有属性（包括private成员，并不可访问）和方法，通过继承可以对对象描述更加清晰，<font color="red">提高代码的复用性</font>。不仅如此，子类还可以根据自己的独特性，扩展属性和方法。</p><h2 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h2><p>通过 <code>extends</code> 关键字让类与类之间产生继承关系。语法：<code>public calss 子类名 extends 父类名{}</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> calss Cat extends Animal&#123;&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>例:<br>创建一个Animal(动物)类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Animal fun1 ... "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Animal fun2 ... "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个Cat(猫)类，然后让Cat类继承自Animal</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就实现了继承，Cat就是Animal的子类  </p><p>就这样实现了一个继承貌似也没有什么特别的意义，继承的意义在于让子类和父类可以产生差异，我们来详细的看看怎样让子类和父类产生差异的，主要有两种方法</p><h3 id="第一种方法，直接在子类加方法"><a href="#第一种方法，直接在子类加方法" class="headerlink" title="第一种方法，直接在子类加方法"></a>第一种方法，直接在子类加方法</h3><p>直接在子类中添加新的方法和成员变量。这意味着父类的成员变量或方法不能满足子类的需要，因此需要添加新的来满足子类的需求，以上面的Cat为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//新增方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">skill</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"猫会抓鱼"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Cat c = <span class="keyword">new</span> Cat();</span><br><span class="line">        c.fun1();</span><br><span class="line">        c.skill();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">打印结果：</span><br><span class="line">Animal fun1 ... </span><br><span class="line">猫会抓鱼</span><br></pre></td></tr></table></figure><p>上例方法中猫的技能在Animal类中没有方法能满足，所以添加了一个新的方法满足了需求，既能调用父类的方法，有能调用自己特有的扩展方法</p><h3 id="第二种方法，覆盖-overriding-父类的方法，还可以被叫做重写"><a href="#第二种方法，覆盖-overriding-父类的方法，还可以被叫做重写" class="headerlink" title="第二种方法，覆盖(overriding)父类的方法，还可以被叫做重写"></a>第二种方法，覆盖(overriding)父类的方法，还可以被叫做重写</h3><p>overriding的作用不是要添加父类没有的方法，而是覆盖父类的方法，（前提是父类方法访问权限不是private，且子类方法权限大于等于父类方法），这里会涉及到几个访问权限修饰符的知识点，不懂可以特别研究下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 子类重写父类的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Cat fun2 ... "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Cat c = <span class="keyword">new</span> Cat();</span><br><span class="line">        c.fun1();</span><br><span class="line">        c.fun2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">打印结果：</span><br><span class="line">Animal fun1 ... </span><br><span class="line">Cat fun2 ...</span><br></pre></td></tr></table></figure><p>这里对上述代码有两个点需要进行一下描述：<br>1、大家也看见了fun2()方法上有一个<code>@Override</code>，@Override表示下面出现的方法会出现重写操作，由编译器检查，如果达不到重写的条件，就会报错。一定程度上增加了代码的安全性和健壮性，可有可无，为了可读性高，留下更好<br>2、覆盖的方法必须与父类定义完全相同，注意这里是方法名和返回值及参数都要相等，拿参数来说，如果参数变了，那么这就不能叫覆盖（重写）了，而是“重载”，这里不深入重载的研究了，不过重写的方法修饰符是可以改变的，不过还是得遵循（子类方法权限大于等于父类方法）定律   </p><p>好，回到上面的例子，这里打印的是<code>Animal fun1 ...</code>和<code>Cat fun2 ...</code>，说明fun1()由于继承的关系执行的是父类的方法，如果Cat里面没有fun2()方法的话肯定也会执行父类里面的fun2()方法，但这里由于子类（Cat）覆盖了父类的fun2()方法，所以执行到了Cat.fun2();最终打印<code>Cat fun2 ...</code>，这就表明overriding成功了</p><h2 id="继承后的子类运行顺序"><a href="#继承后的子类运行顺序" class="headerlink" title="继承后的子类运行顺序"></a>继承后的子类运行顺序</h2><p>子类构造器中的this的调用 → 父类成员变量初始化 → 父类构造方法 → 子类变量初始化 → 子类构造方法<br>究其原因，是子类因为继承特性，所以拥有了父类的数据，也就是成员变量，而子类在写这些数据时，必须先知道父类的如何定义或者初始化的  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是动物类"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是猫类"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Cat c = <span class="keyword">new</span> Cat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">打印结果：</span><br><span class="line">这是动物类</span><br><span class="line">这是猫类</span><br></pre></td></tr></table></figure><p>可见就算是没有构造方法，创建了Cat对象后，也是先调用的父类方法，后调用子类方法   </p><p>总结：<br>1、子类重写父类的方法，必须同父类方法相同<br>2、子类重写父类的方法，子类方法权限需大于等于父类方法<br>3、子类继承父类后调用的运行顺序依次是：父类成员变量初始化 → 父类构造方法 → 子类变量初始化 → 子类构造方法</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java继承是面向对象的最显著的一个特征。继承是从已有的类中派生出新的类，新的类能吸收已有类的数据属性和行为，并能扩展新的能力&lt;/p&gt;
&lt;p&gt;在多个类中存在相同属性和行为时，将这些内容单独抽取到一个类中，那么多个类就不需再次定义这些类和属性，只要继承那个类就行了&lt;/p&gt;
&lt;p&gt;在继承的关系里，被继承的类称为父类、超类或者基类，而继承的类就被称为子类。子类继承了父类的所有属性（包括private成员，并不可访问）和方法，通过继承可以对对象描述更加清晰，&lt;font color=&quot;red&quot;&gt;提高代码的复用性&lt;/font&gt;。不仅如此，子类还可以根据自己的独特性，扩展属性和方法。&lt;/p&gt;
&lt;h2 id=&quot;如何实现&quot;&gt;&lt;a href=&quot;#如何实现&quot; class=&quot;headerlink&quot; title=&quot;如何实现&quot;&gt;&lt;/a&gt;如何实现&lt;/h2&gt;&lt;p&gt;通过 &lt;code&gt;extends&lt;/code&gt; 关键字让类与类之间产生继承关系。语法：&lt;code&gt;public calss 子类名 extends 父类名{}&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; calss Cat extends Animal&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="后台开发" scheme="http://sevennight.cc/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="java" scheme="http://sevennight.cc/tags/java/"/>
    
  </entry>
  
</feed>
